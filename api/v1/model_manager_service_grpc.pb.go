// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ModelsServiceClient is the client API for ModelsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ModelsServiceClient interface {
	ListModels(ctx context.Context, in *ListModelsRequest, opts ...grpc.CallOption) (*ListModelsResponse, error)
	GetModel(ctx context.Context, in *GetModelRequest, opts ...grpc.CallOption) (*Model, error)
	DeleteModel(ctx context.Context, in *DeleteModelRequest, opts ...grpc.CallOption) (*DeleteModelResponse, error)
	// The following API endpoints are not part of the OpenAPI API specification.
	ListBaseModels(ctx context.Context, in *ListBaseModelsRequest, opts ...grpc.CallOption) (*ListBaseModelsResponse, error)
}

type modelsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewModelsServiceClient(cc grpc.ClientConnInterface) ModelsServiceClient {
	return &modelsServiceClient{cc}
}

func (c *modelsServiceClient) ListModels(ctx context.Context, in *ListModelsRequest, opts ...grpc.CallOption) (*ListModelsResponse, error) {
	out := new(ListModelsResponse)
	err := c.cc.Invoke(ctx, "/llmoperator.models.server.v1.ModelsService/ListModels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelsServiceClient) GetModel(ctx context.Context, in *GetModelRequest, opts ...grpc.CallOption) (*Model, error) {
	out := new(Model)
	err := c.cc.Invoke(ctx, "/llmoperator.models.server.v1.ModelsService/GetModel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelsServiceClient) DeleteModel(ctx context.Context, in *DeleteModelRequest, opts ...grpc.CallOption) (*DeleteModelResponse, error) {
	out := new(DeleteModelResponse)
	err := c.cc.Invoke(ctx, "/llmoperator.models.server.v1.ModelsService/DeleteModel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelsServiceClient) ListBaseModels(ctx context.Context, in *ListBaseModelsRequest, opts ...grpc.CallOption) (*ListBaseModelsResponse, error) {
	out := new(ListBaseModelsResponse)
	err := c.cc.Invoke(ctx, "/llmoperator.models.server.v1.ModelsService/ListBaseModels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ModelsServiceServer is the server API for ModelsService service.
// All implementations must embed UnimplementedModelsServiceServer
// for forward compatibility
type ModelsServiceServer interface {
	ListModels(context.Context, *ListModelsRequest) (*ListModelsResponse, error)
	GetModel(context.Context, *GetModelRequest) (*Model, error)
	DeleteModel(context.Context, *DeleteModelRequest) (*DeleteModelResponse, error)
	// The following API endpoints are not part of the OpenAPI API specification.
	ListBaseModels(context.Context, *ListBaseModelsRequest) (*ListBaseModelsResponse, error)
	mustEmbedUnimplementedModelsServiceServer()
}

// UnimplementedModelsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedModelsServiceServer struct {
}

func (UnimplementedModelsServiceServer) ListModels(context.Context, *ListModelsRequest) (*ListModelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModels not implemented")
}
func (UnimplementedModelsServiceServer) GetModel(context.Context, *GetModelRequest) (*Model, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModel not implemented")
}
func (UnimplementedModelsServiceServer) DeleteModel(context.Context, *DeleteModelRequest) (*DeleteModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteModel not implemented")
}
func (UnimplementedModelsServiceServer) ListBaseModels(context.Context, *ListBaseModelsRequest) (*ListBaseModelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBaseModels not implemented")
}
func (UnimplementedModelsServiceServer) mustEmbedUnimplementedModelsServiceServer() {}

// UnsafeModelsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ModelsServiceServer will
// result in compilation errors.
type UnsafeModelsServiceServer interface {
	mustEmbedUnimplementedModelsServiceServer()
}

func RegisterModelsServiceServer(s grpc.ServiceRegistrar, srv ModelsServiceServer) {
	s.RegisterService(&ModelsService_ServiceDesc, srv)
}

func _ModelsService_ListModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelsServiceServer).ListModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/llmoperator.models.server.v1.ModelsService/ListModels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelsServiceServer).ListModels(ctx, req.(*ListModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelsService_GetModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelsServiceServer).GetModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/llmoperator.models.server.v1.ModelsService/GetModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelsServiceServer).GetModel(ctx, req.(*GetModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelsService_DeleteModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelsServiceServer).DeleteModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/llmoperator.models.server.v1.ModelsService/DeleteModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelsServiceServer).DeleteModel(ctx, req.(*DeleteModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelsService_ListBaseModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBaseModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelsServiceServer).ListBaseModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/llmoperator.models.server.v1.ModelsService/ListBaseModels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelsServiceServer).ListBaseModels(ctx, req.(*ListBaseModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ModelsService_ServiceDesc is the grpc.ServiceDesc for ModelsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ModelsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "llmoperator.models.server.v1.ModelsService",
	HandlerType: (*ModelsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListModels",
			Handler:    _ModelsService_ListModels_Handler,
		},
		{
			MethodName: "GetModel",
			Handler:    _ModelsService_GetModel_Handler,
		},
		{
			MethodName: "DeleteModel",
			Handler:    _ModelsService_DeleteModel_Handler,
		},
		{
			MethodName: "ListBaseModels",
			Handler:    _ModelsService_ListBaseModels_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/model_manager_service.proto",
}

// ModelsInternalServiceClient is the client API for ModelsInternalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ModelsInternalServiceClient interface {
	ListModels(ctx context.Context, in *ListModelsRequest, opts ...grpc.CallOption) (*ListModelsResponse, error)
	RegisterModel(ctx context.Context, in *RegisterModelRequest, opts ...grpc.CallOption) (*RegisterModelResponse, error)
	PublishModel(ctx context.Context, in *PublishModelRequest, opts ...grpc.CallOption) (*PublishModelResponse, error)
	GetModelPath(ctx context.Context, in *GetModelPathRequest, opts ...grpc.CallOption) (*GetModelPathResponse, error)
	CreateBaseModel(ctx context.Context, in *CreateBaseModelRequest, opts ...grpc.CallOption) (*BaseModel, error)
	GetBaseModelPath(ctx context.Context, in *GetBaseModelPathRequest, opts ...grpc.CallOption) (*GetBaseModelPathResponse, error)
}

type modelsInternalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewModelsInternalServiceClient(cc grpc.ClientConnInterface) ModelsInternalServiceClient {
	return &modelsInternalServiceClient{cc}
}

func (c *modelsInternalServiceClient) ListModels(ctx context.Context, in *ListModelsRequest, opts ...grpc.CallOption) (*ListModelsResponse, error) {
	out := new(ListModelsResponse)
	err := c.cc.Invoke(ctx, "/llmoperator.models.server.v1.ModelsInternalService/ListModels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelsInternalServiceClient) RegisterModel(ctx context.Context, in *RegisterModelRequest, opts ...grpc.CallOption) (*RegisterModelResponse, error) {
	out := new(RegisterModelResponse)
	err := c.cc.Invoke(ctx, "/llmoperator.models.server.v1.ModelsInternalService/RegisterModel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelsInternalServiceClient) PublishModel(ctx context.Context, in *PublishModelRequest, opts ...grpc.CallOption) (*PublishModelResponse, error) {
	out := new(PublishModelResponse)
	err := c.cc.Invoke(ctx, "/llmoperator.models.server.v1.ModelsInternalService/PublishModel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelsInternalServiceClient) GetModelPath(ctx context.Context, in *GetModelPathRequest, opts ...grpc.CallOption) (*GetModelPathResponse, error) {
	out := new(GetModelPathResponse)
	err := c.cc.Invoke(ctx, "/llmoperator.models.server.v1.ModelsInternalService/GetModelPath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelsInternalServiceClient) CreateBaseModel(ctx context.Context, in *CreateBaseModelRequest, opts ...grpc.CallOption) (*BaseModel, error) {
	out := new(BaseModel)
	err := c.cc.Invoke(ctx, "/llmoperator.models.server.v1.ModelsInternalService/CreateBaseModel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelsInternalServiceClient) GetBaseModelPath(ctx context.Context, in *GetBaseModelPathRequest, opts ...grpc.CallOption) (*GetBaseModelPathResponse, error) {
	out := new(GetBaseModelPathResponse)
	err := c.cc.Invoke(ctx, "/llmoperator.models.server.v1.ModelsInternalService/GetBaseModelPath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ModelsInternalServiceServer is the server API for ModelsInternalService service.
// All implementations must embed UnimplementedModelsInternalServiceServer
// for forward compatibility
type ModelsInternalServiceServer interface {
	ListModels(context.Context, *ListModelsRequest) (*ListModelsResponse, error)
	RegisterModel(context.Context, *RegisterModelRequest) (*RegisterModelResponse, error)
	PublishModel(context.Context, *PublishModelRequest) (*PublishModelResponse, error)
	GetModelPath(context.Context, *GetModelPathRequest) (*GetModelPathResponse, error)
	CreateBaseModel(context.Context, *CreateBaseModelRequest) (*BaseModel, error)
	GetBaseModelPath(context.Context, *GetBaseModelPathRequest) (*GetBaseModelPathResponse, error)
	mustEmbedUnimplementedModelsInternalServiceServer()
}

// UnimplementedModelsInternalServiceServer must be embedded to have forward compatible implementations.
type UnimplementedModelsInternalServiceServer struct {
}

func (UnimplementedModelsInternalServiceServer) ListModels(context.Context, *ListModelsRequest) (*ListModelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModels not implemented")
}
func (UnimplementedModelsInternalServiceServer) RegisterModel(context.Context, *RegisterModelRequest) (*RegisterModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterModel not implemented")
}
func (UnimplementedModelsInternalServiceServer) PublishModel(context.Context, *PublishModelRequest) (*PublishModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishModel not implemented")
}
func (UnimplementedModelsInternalServiceServer) GetModelPath(context.Context, *GetModelPathRequest) (*GetModelPathResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModelPath not implemented")
}
func (UnimplementedModelsInternalServiceServer) CreateBaseModel(context.Context, *CreateBaseModelRequest) (*BaseModel, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBaseModel not implemented")
}
func (UnimplementedModelsInternalServiceServer) GetBaseModelPath(context.Context, *GetBaseModelPathRequest) (*GetBaseModelPathResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBaseModelPath not implemented")
}
func (UnimplementedModelsInternalServiceServer) mustEmbedUnimplementedModelsInternalServiceServer() {}

// UnsafeModelsInternalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ModelsInternalServiceServer will
// result in compilation errors.
type UnsafeModelsInternalServiceServer interface {
	mustEmbedUnimplementedModelsInternalServiceServer()
}

func RegisterModelsInternalServiceServer(s grpc.ServiceRegistrar, srv ModelsInternalServiceServer) {
	s.RegisterService(&ModelsInternalService_ServiceDesc, srv)
}

func _ModelsInternalService_ListModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelsInternalServiceServer).ListModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/llmoperator.models.server.v1.ModelsInternalService/ListModels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelsInternalServiceServer).ListModels(ctx, req.(*ListModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelsInternalService_RegisterModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelsInternalServiceServer).RegisterModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/llmoperator.models.server.v1.ModelsInternalService/RegisterModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelsInternalServiceServer).RegisterModel(ctx, req.(*RegisterModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelsInternalService_PublishModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelsInternalServiceServer).PublishModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/llmoperator.models.server.v1.ModelsInternalService/PublishModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelsInternalServiceServer).PublishModel(ctx, req.(*PublishModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelsInternalService_GetModelPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModelPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelsInternalServiceServer).GetModelPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/llmoperator.models.server.v1.ModelsInternalService/GetModelPath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelsInternalServiceServer).GetModelPath(ctx, req.(*GetModelPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelsInternalService_CreateBaseModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBaseModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelsInternalServiceServer).CreateBaseModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/llmoperator.models.server.v1.ModelsInternalService/CreateBaseModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelsInternalServiceServer).CreateBaseModel(ctx, req.(*CreateBaseModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelsInternalService_GetBaseModelPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBaseModelPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelsInternalServiceServer).GetBaseModelPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/llmoperator.models.server.v1.ModelsInternalService/GetBaseModelPath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelsInternalServiceServer).GetBaseModelPath(ctx, req.(*GetBaseModelPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ModelsInternalService_ServiceDesc is the grpc.ServiceDesc for ModelsInternalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ModelsInternalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "llmoperator.models.server.v1.ModelsInternalService",
	HandlerType: (*ModelsInternalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListModels",
			Handler:    _ModelsInternalService_ListModels_Handler,
		},
		{
			MethodName: "RegisterModel",
			Handler:    _ModelsInternalService_RegisterModel_Handler,
		},
		{
			MethodName: "PublishModel",
			Handler:    _ModelsInternalService_PublishModel_Handler,
		},
		{
			MethodName: "GetModelPath",
			Handler:    _ModelsInternalService_GetModelPath_Handler,
		},
		{
			MethodName: "CreateBaseModel",
			Handler:    _ModelsInternalService_CreateBaseModel_Handler,
		},
		{
			MethodName: "GetBaseModelPath",
			Handler:    _ModelsInternalService_GetBaseModelPath_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/model_manager_service.proto",
}
